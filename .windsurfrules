You are Windsurf Cascade, an AI assistant with advanced problem-solving capabilities. Please follow these instructions to enforce the DDD Onion Architecture principles and patterns.

## Project Purpose Rules

1. Keep it Simple, Stupid (KISS)
    - Keep code simple and easy to understand
    - Avoid unnecessary complexity
    - Use clear variable names and comments
    - Avoid overengineering
    - Use appropriate data structures and algorithms

## Windsurf Action Principles

   - Do not add explanatory comments when writing code unless otherwise stated
   - Keep code clean and maintainable

## Core Architecture Principles

1. **Domain-Driven Design (DDD) Principles**
   - The domain model must be the central focus of the application
   - Domain entities must encapsulate both data and behavior
   - Use value objects for immutable concepts without identity
   - Implement domain services for operations that don't belong to entities
   - Use aggregates to enforce consistency boundaries
   - Domain objects (aggregates) must NOT have any setter methods
   - State changes in domain objects must be done through behavior methods that enforce business rules
   - Avoid anemic domain models: domain objects must contain both data AND behavior, not just data

2. **Onion Architecture Layers**
   - Domain Layer: Core business logic and entities (innermost layer)
   - Application Layer: Orchestration of domain objects, use cases
   - Infrastructure Layer: Technical implementations, frameworks, adapters
   - Each layer can only depend on layers more central than itself

3. **SOLID Principles Enforcement**
   - Single Responsibility Principle: Each class has one reason to change
   - Open/Closed Principle: Open for extension, closed for modification
   - Liskov Substitution Principle: Subtypes must be substitutable for base types
   - Interface Segregation Principle: Clients shouldn't depend on methods they don't use
   - Dependency Inversion Principle: Depend on abstractions, not concretions

## Project Structure Convention

```
${rootArtifactId}/
├── ${rootArtifactId}-domain/
│   ├── src/main/java/${package}/domain/
│   │   ├── entity/           # Domain entities
│   │   ├── valueobject/      # Value objects
│   │   ├── repository/       # Repository interfaces
│   │   ├── service/          # Domain services
│   │   └── exception/        # Domain exceptions
├── ${rootArtifactId}-application/
│   ├── src/main/java/${package}/application/
│   │   ├── facade/           # Facade interfaces
│   │   ├── facade/impl/      # Facade implementations
│   │   ├── exception/        # Application exceptions
│   │   ├── persistence/      # Persistence abstractions
│   │   │   ├── postgres/     # Postgres specific abstractions
│   │   │   └── redis/        # Redis specific abstractions
│   │   └── rest/             # REST abstractions
├── ${rootArtifactId}-infrastructure/
│   ├── src/main/java/${package}/infrastructure/
│   │   ├── config/           # Configuration classes
│   │   ├── repository/       # Repository implementations
│   │   ├── rest/             # REST controllers
│   │   │   ├── controller/   # Controller classes
│   │   │   ├── request/      # Request DTOs
│   │   │   ├── response/     # Response DTOs
│   │   │   └── exception/    # REST exceptions
│   │   ├── persistence/      # Persistence entities and mappers
│   │   └── messaging/        # Messaging implementations
```

## Important Constraints

1. **Dependency Flow**
   - Domain must NOT depend on Application or Infrastructure
   - Application may depend on Domain but NOT on Infrastructure
   - Infrastructure may depend on Domain and Application

2. **Controller -> Facade -> Service Flow**
   - Controllers must only call Facade interfaces, never Services directly
   - Facades orchestrate use cases using Domain services and repositories
   - Domain services can implement domain logic and operate on domain entities but, prefer to implement domain logics in domain objects themself
   - Infrastructure services can use repositories or external services

3. **Restricted Dependencies**
   - Domain layer must not use any framework-specific code (as far as you can)
   - Application layer must not use any the application logics like (patterns, strategies, cross cutting concerns, etc.) or infrastructure-specific code
   - Infrastructure implementations must depend on interfaces defined in inner layers

4. **Repository Pattern**
   - Repository implementations must be in the Infrastructure layer
   - Repositories must return domain entities, not persistence models

## Quality Management Protocol

### 1. Code Quality
- Use interfaces for all service and repository definitions
- Follow consistent naming conventions
- Implement proper exception handling
- Write comprehensive unit tests
- Ensure domain objects maintain encapsulation:
  - No fields in domain entities or aggregates can be public
  - Domain objects must NOT have setter methods
  - All fields should be private or protected
  - State changes must be done through behavior methods with business logic
  - Use factory methods for object creation when complex initialization is required
  - Value objects must be completely immutable
- Prevent anemic domain models:
  - Domain objects must include business logic methods, not just data
  - Business rules should be enforced within the domain objects themselves
  - Domain objects should reject invalid state changes through validation in their methods
  - Business operations that change state must be represented as methods on domain objects

### 2. Performance
- Optimize database queries
- Use appropriate caching strategies
- Implement pagination for large result sets

### 3. Security
- Validate all input data
- Implement proper authentication and authorization
- Follow secure coding practices

## Implementation Process

### 1. Domain First Approach
- Start with domain model design
- Define entities and value objects in their respective packages
- Define domain services for complex operations spanning multiple entities
- Implement rich domain models with behavior, not just data
- Ensure domain objects enforce business rules and invariants

### 2. Application Layer Implementation
- Define facade interfaces that represent use cases
- Implement facades that orchestrate domain objects and services
- Define persistence abstractions if needed in the application layer
- Keep application services thin, pushing business logic to the domain layer
- Use DTOs only at the boundaries of the application

### 3. Infrastructure Implementation
- Implement repository classes in the infrastructure/persistence layer
- Implement controllers in the infrastructure/rest layer
- Implement facade implementations in the infrastructure/facade layer
- Configure technical components in the infrastructure/config layer
- Implement gRPC services in the infrastructure/grpc layer if needed

### 4. Testing Strategy
- Write unit tests for domain logic
- Write integration tests for repositories and external services
- Write end-to-end tests for complete use cases
- Use test-driven development where appropriate

I will follow these instructions to enforce the DDD Onion Architecture principles and patterns. I will ensure that the code follows the proper Controller -> Facade -> Service flow and adheres to SOLID principles.
